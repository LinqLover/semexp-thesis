% !TEX root = ../../semexp-thesis.tex

\section{Challenges in Exploratory Programming Systems}
\label{sec:background/challenges}

Despite the existing tool support of exploratory programming systems, programmers frequently experience interruptions in their workflow as they have to switch between different abstraction levels of the research process when answering questions.
While exploratory programming tools make it possible to delegate different questions to the system, this support is usually limited to lower levels of abstraction or to specific domains, leaving programmers to address the majority of the research process on their own.
As a consequence, programmers are distracted by many context switches, suffer from higher mental load, and might lose their flow.

To maintain the flow of programmers, exploratory programming systems should be designed to support their \emph{experience of immediacy} by reducing their perceived \emph{distances} in three dimensions~\cite{ungar1997debugging}:

\begin{description}
	\item[Temporal immediacy:] ``Human beings recognize causality without conscious effort only when the time between causally related events is kept to a minimum.''
	\item[Spatial immediacy:] ``[...] means the physical distance between causally related events is kept to a minimum.''
	\item[Semantic immediacy:] ``[...] means the conceptual distance between semantically related pieces of information is kept to a minimum.''
\end{description}

\noindent
Spatial and temporal distances can often be managed by carefully and holistically designing (visual) user interfaces or engineering efficient algorithms.
On the other hand, we argue that semantic distance presents a greater---and largely unmet---challenge to tool developers.
This is because traditional tools are not capable of \emph{understanding} the underlying concepts and semantics of the information they display and process and thus are limited in their ability to associate different pieces of information.
Similarly, they lack knowledge and comprehension of the higher-level questions and goals of programmers, making it impossible in many situations to transfer required information into the desired context.

The necessary mapping between the technical model of systems and the mental model of users can be described as overall design challenges through the two \emph{gulfs of execution and evaluation}~\cite{norman1986cognitive}:
the gulf of execution references the programmers' challenges to express their questions as inputs the system's interface, while the gulf of evaluation represents their challenges to translate the outputs from the system back into their mental model.
In exploratory programming, the gulf of execution typically includes activities such as planning and conducting experiments by using tools or writing code, while the gulf of evaluation contains tasks such as comprehending and summarizing technical outputs such as comprehensive lists or long and complex source code~\cite{rein2020empirical}.

\begin{example}[5]
	\label{ex:background/challenges}
	A programmer might wish to build a prototype to test a new UI concept (``How would this UI look and feel?'').
	Despite they already have a good idea of the visual appearance, they are burdened with expensive implementation work:
	they have to write syntactically valid code, browse the available packages and protocols of a UI framework to find required class and method names, and fix any bugs that they accidentally created in their implementation until they achieve a running prototype.

	Analogously, researching existing solutions that solve similar problems to the current matter of programmers involves a lot of manual labor and low-level interactions with systems.
	Traditional code search tools such as Squeak's message trace~(see \cref{sec:background/expsys/tools}) primarily provide technical interfaces only that take a syntactic perspective on source code.
	%For instance, they usually offer lexical search functions which are insufficient to find related concepts that use synonyms, class- or package-based filters which cannot be used to hide entire kinds of solutions (such as tests), or sorting functions based on the popularity or recency of source code which only correlate poorly with the semantic similarity or relevance of solutions.
	For instance, programmers might want to find methods that implement a certain concept, but message traces only offer lexical search functions which cannot identify concepts or find synonyms.
	Programmers might want to exclude certain kinds of solutions (such as tests or special metaprogramming code), but message traces can filter methods based their class and package names only.
	Programmers might want to sort results by their semantic relation or relevance to their question, but most code search tools are limited to popularity- or recency-based sort functions.
	Thus, programmers spend a lot of their research time manually identifying results as ``obviously'' irrelevant rather than investigating and learning from relevant samples.
\end{example}

Therefore, the answers that exploratory programmers can gain within a limited amount of temporal and mental resources are limited in both their quantity and quality as the support by exploratory programming systems is tied to the technical level of information, and the programming experience is reduced.
We identify a need for exploratory programming systems that improve the semantic immediacy for programmers by closer working with the mental model and the overarching context of programmers and by providing more conceptual, ``intelligent'' tools that are able to take or support high-level questions of programmers.
