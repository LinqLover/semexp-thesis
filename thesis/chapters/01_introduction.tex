% !TEX root = ../semexp-thesis.tex

\setchapterpreamble[uc][.75\textwidth]{%
	%\dictum[John C. Maxwell]{%
	%	The future belongs to the curious. The ones who are not afraid to try it, explore it, poke at it, question it, and turn it inside out.
	%}
	\dictum[Albert Einstein]{%
		The important thing is not to stop questioning. Curiosity has its own reason for existing.
	}
}

\chapter{Introduction}
\label{cha:introduction}

In the realm of software development, curiosity is essential for understanding problems and finding solutions.
%As programmers want to develop a new feature, fix a bug, or just understand a system, they need to gather a plethora of insights:
Programmers spend a large amount of time searching for useful interfaces, concepts, and methods---and they spend a similar amount of time understanding systems, plugging concepts together, and experimenting with prototypes.
All of this involves raising many different questions:
\emph{%
	which parts of this system do I need to touch to add a new feature?
	%What packages and methods are already there that could do the job for me?
	%How does this feature work?
	%What state does this object have, and how can I access or manipulate it?
	What information does this object contain, and how can I access or manipulate it?
	Why has this cache not been reset---how have others solved this problem?
	%Can I do this to achieve that and does this make a good solution?
	What would it look and feel like if we placed this button there?
}

All this need for knowledge can be expressed as \emph{questions}, and we can say programmers have \emph{conversations} with the system in which they conduct \emph{experiments} to collect the information required to answer these questions~\cite{taeumel2022pattern}.
Good conversations are vivid, rapid, rich: many answers lead to new thoughts, revised questions, alternative approaches---and with every further question, programmers gradually develop their understanding of the systems and problems they are working with, until they achieve a viable solution and their curiosity is satisfied for the moment.

\emph{Exploratory programming systems}~\cite{sandberg1988smalltalk,rein2018exploratory} are designed to support such conversations by offering several \emph{tools}, through which programmers can interact with software systems (or their parts) to answer questions.
One prominent exploratory programming system is \emph{Squeak"/Smalltalk}~\cite{goldberg1983smalltalk,thiede2023squeak}, where \emph{objects} serve as the main building block for defining systems. %creating and running programs.
Objects execute behavior by sending messages to each other, and they handle messages by accessing and changing their internal state.
%Programmers can explore the objects in a system by using tools to inspect and modify their state and behavior.
Through tools of the Smalltalk system, programmers can explore and develop the objects in a running system by inspecting and modifying their state and behavior.

In Squeak, a central tool for exploratory programming is the \emph{workspace}:
%through it, programmers can prototype new solutions, browse existing implementations, or inspect objects from the live system.
%through its text-based interface,
here, programmers can write and evaluate scripts to prototype new solutions, browse the classes of objects to research and discover existing implementations and protocols, or inspect particular objects and send them messages to explore their state and capabilities.
%for example, a Smalltalk programmer can use an \emph{inspector} to search the internal state of an object, study the source code of a class in a \emph{browser} to discover helpful protocols and methods, or evaluate a script in a \emph{workspace} to try out methods and their combinations.

%\ParSep
\section*{The Cost of Questioning}

%However, every question has its price.
However, exploratory conversations can be expensive.
Even simple questions might demand the full attention and structured thinking from programmers:
\emph{%
%\begin{quote}\itshape
	when has this order been filed? I can find that out by inspecting this object. Ah, it has a \code{creationDate} field, but oh no, why is this just a plain number? It could be a Unix timestamp. How can I convert that into a human-readable representation? Is there any method on \code{Date} that does this for me? Seems not so. Maybe \code{DateAndTime}? Yes, \code{DateAndTime fromUnixTime: creationDate} should do the job ... but wait, surely this order has not been created in year 56170? Is this actually a millisecond timestamp? Okay, so I can divide it by 1000 and try again ... fix that syntax slip ... alright, so this order has been filed on March 14th this year. What was I going to do again?
}%\end{quote}

We note two major challenges in the exploratory programming workflow for that traditional exploratory programming systems have not yet found sufficient solutions: \emph{semantic distances} and \emph{information overload}.
First, programmers regularly face substantial \emph{semantic distances} between their high-level intentions and the low-level interfaces of systems.
Programmers have to manually bridge these distances by translating conceptual questions into technical operations and interpreting technical results in terms of their mental model.

Second, they face \emph{information overload} as the number of possible information sources (such as comprehensive interfaces, documentation, and examples), as well as the number of possible experiments and prototypes, often exceed human capabilities for information processing within limited time.
Thus, programmers are forced to consider only a small, often less relevant fraction of the available data.
If they nevertheless decide to skim all available information, they are frequently \emph{distracted} by irrelevant artifacts while trying to filter them.

All these mental overheads and distractions impede exploratory conversations and restrain programmers from maintaining their flow, exhausting expedient options, and finding feasible solutions.

%\ParSep
\section*{AI to the Rescue?}

%On the other hand, the ongoing progress of artificial intelligence (AI) and machine learning (ML) methods has already simplified and enriched various other domains.
At the same time, the recent progress of artificial intelligence (AI) and machine learning (ML) methods has already supported users and programmers at bridging barriers and handling extensive information in various domains.
Search and recommendation algorithms on online marketplaces, social-media platforms, and streaming services use \emph{document embeddings}~\cite{mikolov2013efficient,devlin2019bert} to find objects based on their \emph{semantics} or meaning. %(from Ancient Greek \emph{sēmantikós}, i.e., significance or meaning).
Generative AI tools such as ChatGPT\footnote{\url{https://chat.openai.com/}}, Claude\footnote{\url{https://claude.ai/}}, and others~\cite{vaswani2017attention,radford2018improving,zhao2023survey} employ \emph{large language models} (LLMs) to help people create, automate, and learn. %have been widely adopted by people and companies in the last two years for creating, automating, and learning.

In particular, many programmers have started to leverage generative AI: millions of developer generate code with the help of code completion tools such as GitHub Copilot\footnote{\url{https://github.com/features/copilot}}, Tabnine\footnote{\url{https://www.tabnine.com/}}, and others, or they use conversational agents such as GitHub Copilot Chat%\footnote{\url{https://docs.github.com/en/copilot/github-copilot-chat}}
 to explore and modify code bases.
Similarly, tools such as Microsoft Visual Studio IntelliCode\footnote{\url{https://visualstudio.microsoft.com/services/intellicode/}} and Sourcegraph\footnote{\url{https://sourcegraph.com/}} employ embeddings to find and rank relevant source code snippets.

We subsume both these technologies---\emph{semantic retrieval} using document embeddings and \emph{text generation} using LLMs---under the term \emph{semantic technologies}.

%\ParSep
\section*{Research Objective and Structure}

%Yet, only few approaches have used the capabilities of semantic technologies to improve the exploratory programming workflow. % oldtodo: vague and bold - make kind of improvement more precise? cite existing work here?
%However,
We believe that semantic technologies have significant potential to support exploratory programmers in processing extensive information and bridging semantic distances.
%This leads us to our primary research question:
%
%\begin{quote}
%	How can tool developers use semantic technologies to improve the exploratory programming experience?
%\end{quote}
%
%We decompose this question into the following secondary research questions:
%
%\begin{enumerate}[label=RQ\arabic*]
%	\item \bold{How can tool developers use semantic technologies to gather, process, and augment information for exploratory programmers?}
%		How can they retrieve relevant information from the programming system? How can they analyze this information and generate new knowledge?
%		How can they manage information throughout this process?
%	\item \bold{How can tool developers integrate new semantic capabilities into the exploratory programming workflow?}
%		How should they design programming tools that harness the potential of semantic capabilities?
%		How can exploratory programmers interact with these capabilities, and how does this affect their programming experience?
%		In light of new semantic capabilities, can existing UI languages and mechanisms of exploratory programming systems uphold their adequacy, or do new, more semantics-oriented interfaces offer greater benefits?
%	\item \bold{What are practical considerations for tool developers that use semantic technologies?}
%		What current challenges and limitations of semantic technologies should they be aware of and how can they cope with them?
%		How can they design semantic interfaces to achieve both a good user experience and developer experience?
%\end{enumerate}
This leads us to our research question:
%
\begin{quote}
	How can we augment the exploratory programming workflow by integrating semantic technologies into exploratory programming systems?
\end{quote}

That is, we want to study possible applications of semantic technologies for exploratory programming, investigate tool designs and interaction mechanisms for giving programmers convenient access to these technologies, and collect practical considerations for the design and implementation of such tools.

In answer to this question, our thesis statement reads as follows:
%
\begin{quote}
	%By integrating means for programmers into exploratory programming systems to closely collaborate with semantic technologies, tool developers can augment and streamline the exploratory programming workflow.
	By tightly integrating \emph{semantic interfaces} into exploratory programming systems through which programmers can easily delegate flexible portions of their workflow to \emph{intelligent agents} and thus closely \emph{collaborate} with semantic technologies, we can augment and streamline the exploratory programming workflow.
\end{quote}

For this, we propose a model for an \emph{augmented exploratory programming workflow} in which the exploratory activities of programmers are tracked and anticipated, and in which programmers are enabled to access and interact with AI-suggested experiments and results through a \emph{semantic workspace}.
%We believe that our approach will allow tool developers to tightly integrate semantic technologies into exploratory programming systems, streamline and augment the exploratory workflow, and provide a solid programming experience to programmers by enabling them to cooperate with intelligent tools.
We believe that our approach will allow tool developers to design tools for exploratory programming systems that provide an improved programming experience to programmers by enabling them to collaborate with semantic technologies.

To study this hypothesis, we make the following contributions:
%
\begin{enumerate}%[label=C\arabic*]
	\item We propose the \emph{augmented exploratory programming workflow}, which captures the traditional process and challenges of exploratory programmers and describes possible starting points for integrating semantic technologies.
	\item We present a new \emph{semantic workspace} as a conceptual design for exploratory programming systems that support an augmented exploratory programming workflow by providing new or enhanced \emph{semantic interfaces} for programmers.
	\item We describe our architecture of a \emph{semantic exploration kernel} with different components that use semantic technologies to augment exploratory programming tools, namely \emph{semantic suggestions} and \emph{semantic conversations}, and we implement a prototype for Squeak"/Smalltalk using OpenAI's language models.
	%\item We discuss the feasibility and limitations, programming experience, and development considerations of our approach by implementing a prototype of the semantic workspace in Squeak/Smalltalk using OpenAI's transformer models and by showcasing different applications of the prototype.
\end{enumerate}

We make all artifacts of our research available in a public GitHub repository\footnote{\url{https://github.com/hpi-swa-lab/SemanticSqueak}}. % todo: commit all experiments!

We organize the remainder of this thesis as follows:
%
\begin{description}[noextralabelsep]
	\item[\cref{cha:background}] introduces theoretical foundations behind exploratory programming (systems) and semantic technologies and describes how the challenges of the former may be addressed by the opportunities of the latter.
	\item[\cref{cha:approach}] presents our model of the augmented exploratory programming workflow and describes our conception of a semantic workspace.
	\item[\cref{cha:design}] describes the high-level architecture of the semantic exploration kernel and explains its fundamental components: a \emph{suggestion engine} and a \emph{semantic exploratory agent}.
	\item[\cref{cha:suggestions}] discusses the application of semantic retrieval methods for suggesting experiments.
	\item[\cref{cha:agent}] describes our construction of an exploratory programming agent for implementing conversational interfaces and automating experiments.
	\item[\cref{cha:implementation}] sketches the implementation of our prototype by integrating it with the Squeak"/Smalltalk programming system and our \semtex framework for semantic technologies that uses OpenAI's language models.
	\item[\cref{cha:application}] illustrates applications of the semantic workspace through different case studies.
	\item[\cref{cha:discussion}] discusses opportunities and challenges of semantic technologies for augmenting the exploratory programming workflow regarding technical feasibility, programming experience, and considerations for tool developers.
	\item[\cref{cha:related_work}] provides an overview of related work in the fields of exploratory programming and semantic technologies.
	\item[\cref{cha:conclusion}] summarizes our results and discusses possible directions for future work.
\end{description}
